id: dsq-937490179
date: 2011-07-27T22:47:26.0000000+02:00
name: Dadv
avatar: https://disqus.com/api/users/avatars/Dadv.jpg
message: '<p>Bonjour,</p><p>J&amp;#39ai suivi avec attention votre intervention au MIX 11 et j&amp;#39ai voulu essayer certaines choses avec les sources fournies.</p><p>En premier lieu je cherchais &amp;#224 faire en sorte que MefContrib puisse charger une dll autre part que dans bin, j&amp;#39ai donc modifi&amp;#233 le fichier AppStart_MefContribMVC3.cs comme suit :</p><p>public static class AppStart_MefContribMVC3<br>    {<br>        public static void Start()<br>        {<br>            // Register the CompositionContainerLifetimeHttpModule HttpModule.<br>            // This makes sure everything is cleaned up correctly after each request.<br>            CompositionContainerLifetimeHttpModule.Register();</p><p>            // Create MEF catalog based on the contents of ~/bin.<br>            //<br>            // Note that any class in the referenced assemblies implementing in "IController"<br>            // is automatically exported to MEF. There is no need for explicit [Export] attributes<br>            // on ASP.NET MVC controllers. When implementing multiple constructors ensure that<br>            // there is one constructor marked with the [ImportingConstructor] attribute.<br>            var catalog = new AggregateCatalog(<br>                [b]new DirectoryCatalog(System.IO.Path.Combine(System.AppDomain.CurrentDomain.BaseDirectory, "Plugins")),[/b]<br>                new DirectoryCatalog("bin"),<br>                new ConventionCatalog(new MvcApplicationRegistry())); // Note: add your own (convention)catalogs here if needed.</p><p>            // Tell MVC3 to use MEF as its dependency resolver.<br>            var dependencyResolver = new CompositionDependencyResolver(catalog);<br>            DependencyResolver.SetResolver(dependencyResolver);</p><p>            // Tell MVC3 to resolve dependencies in controllers<br>            ControllerBuilder.Current.SetControllerFactory(<br>                new DefaultControllerFactory(<br>                    new CompositionControllerActivator(dependencyResolver)));</p><p>            // Tell MVC3 to resolve dependencies in filters<br>            FilterProviders.Providers.Remove(FilterProviders.Providers.Single(f =&gt; f is FilterAttributeFilterProvider));<br>            FilterProviders.Providers.Add(new CompositionFilterAttributeFilterProvider(dependencyResolver));</p><p>            // Tell MVC3 to resolve dependencies in model validators<br>            ModelValidatorProviders.Providers.Remove(ModelValidatorProviders.Providers.OfType&lt;DataAnnotationsModelValidatorProvider&gt;().Single());<br>            ModelValidatorProviders.Providers.Add(<br>                new CompositionDataAnnotationsModelValidatorProvider(dependencyResolver));</p><p>            // Tell MVC3 to resolve model binders through MEF. Note that a model binder should be decorated<br>            // with [ModelBinderExport].<br>            ModelBinderProviders.BinderProviders.Add(<br>                new CompositionModelBinderProvider(dependencyResolver));<br>        }<br>    }</p><p>Sans avoir le succ&amp;#232s escompt&amp;#233.</p><p>Je me suis donc orient&amp;#233 vers une impl&amp;#233mentation de PartRegistry :</p><p>using System;<br>using System.Collections.Generic;<br>using System.ComponentModel.Composition;<br>using System.IO;<br>using System.Linq;<br>using System.Reflection;<br>using System.Web;<br>using MefContrib.Hosting.Conventions.Configuration;<br>using MefContrib.Hosting.Conventions;<br>using System.Web.Mvc;<br>using MefContrib.Web.Mvc;</p><p>namespace MefLocalTests.Codes<br>{<br>    public class PluginMvcApplicationRegistry : PartRegistry<br>    {<br>        /// &lt;summary&gt;<br>        /// Initializes a new instance of the &lt;see cref="MvcApplicationRegistry"/&gt; class.<br>        /// &lt;/summary&gt;<br>        public PluginMvcApplicationRegistry()<br>        {<br>            Scan(x =&gt;<br>            {<br>                x.Assembly(Assembly.GetExecutingAssembly());<br>                x.Directory(Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "Plugins"));<br>                x.Directory(Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "bin"));<br>            });</p><p>            Part()<br>                .ForTypesAssignableFrom&lt;IController&gt;()<br>                .MakeNonShared()<br>                .AddMetadata(new PartCreationScopeAttribute(PartCreationScope.Default))<br>                .ExportAs&lt;IController&gt;()<br>                .Export()<br>                .Imports(x =&gt;<br>                {<br>                    x.Import().Members(<br>                        m =&gt; new[] { m.GetConstructors().FirstOrDefault(c =&gt; c.GetCustomAttributes(typeof(ImportingConstructorAttribute), false).Length &gt; 0) ?? m.GetGreediestConstructor() });<br>                    x.Import().Members(<br>                        m =&gt; m.GetMembers().Where(mbr =&gt; mbr.GetCustomAttributes(typeof(ImportAttribute), false).Length &gt; 0).ToArray());<br>                });<br>        }<br>    }<br>}</p><p>et</p><p> public static class AppStart_MefContribMVC3<br>    {<br>        public static void Start()<br>        {<br>            // Register the CompositionContainerLifetimeHttpModule HttpModule.<br>            // This makes sure everything is cleaned up correctly after each request.<br>            CompositionContainerLifetimeHttpModule.Register();</p><p>            // Create MEF catalog based on the contents of ~/bin.<br>            //<br>            // Note that any class in the referenced assemblies implementing in "IController"<br>            // is automatically exported to MEF. There is no need for explicit [Export] attributes<br>            // on ASP.NET MVC controllers. When implementing multiple constructors ensure that<br>            // there is one constructor marked with the [ImportingConstructor] attribute.<br>            var catalog = new AggregateCatalog(<br>                new DirectoryCatalog("bin"),<br>                new ConventionCatalog([b]new PluginMvcApplicationRegistry()[/b])); // Note: add your own (convention)catalogs here if needed.</p><p>            // Tell MVC3 to use MEF as its dependency resolver.<br>            var dependencyResolver = new CompositionDependencyResolver(catalog);<br>            DependencyResolver.SetResolver(dependencyResolver);</p><p>            // Tell MVC3 to resolve dependencies in controllers<br>            ControllerBuilder.Current.SetControllerFactory(<br>                new DefaultControllerFactory(<br>                    new CompositionControllerActivator(dependencyResolver)));</p><p>            // Tell MVC3 to resolve dependencies in filters<br>            FilterProviders.Providers.Remove(FilterProviders.Providers.Single(f =&gt; f is FilterAttributeFilterProvider));<br>            FilterProviders.Providers.Add(new CompositionFilterAttributeFilterProvider(dependencyResolver));</p><p>            // Tell MVC3 to resolve dependencies in model validators<br>            ModelValidatorProviders.Providers.Remove(ModelValidatorProviders.Providers.OfType&lt;DataAnnotationsModelValidatorProvider&gt;().Single());<br>            ModelValidatorProviders.Providers.Add(<br>                new CompositionDataAnnotationsModelValidatorProvider(dependencyResolver));</p><p>            // Tell MVC3 to resolve model binders through MEF. Note that a model binder should be decorated<br>            // with [ModelBinderExport].<br>            ModelBinderProviders.BinderProviders.Add(<br>                new CompositionModelBinderProvider(dependencyResolver));<br>        }<br>    }</p><p>Mais l&amp;#224 encore, aucun succ&amp;#232s.</p><p>Par contre si je met ma dll dans le bin, tout fonctionne parfaitement.</p><p>Pouvez vous m&amp;#39indiquer la marche &amp;#224 suivre pour externaliser le dossier contenant les dll d&amp;#39export svp ?</p><p>D&amp;#39avance merci,</p><p>Dadv</p><p>----</p><p>Hi,</p><p>I want to make MefContrib load a external Dll in an other directory than bin, so i changed the AppStart_MefContribMVC3.cs file :</p><p>public static class AppStart_MefContribMVC3<br>    {<br>        public static void Start()<br>        {<br>            // Register the CompositionContainerLifetimeHttpModule HttpModule.<br>            // This makes sure everything is cleaned up correctly after each request.<br>            CompositionContainerLifetimeHttpModule.Register();</p><p>            // Create MEF catalog based on the contents of ~/bin.<br>            //<br>            // Note that any class in the referenced assemblies implementing in "IController"<br>            // is automatically exported to MEF. There is no need for explicit [Export] attributes<br>            // on ASP.NET MVC controllers. When implementing multiple constructors ensure that<br>            // there is one constructor marked with the [ImportingConstructor] attribute.<br>            var catalog = new AggregateCatalog(<br>               [b] new DirectoryCatalog(System.IO.Path.Combine(System.AppDomain.CurrentDomain.BaseDirectory, "Plugins")),[/b]<br>                new DirectoryCatalog("bin"),<br>                new ConventionCatalog(new MvcApplicationRegistry())); // Note: add your own (convention)catalogs here if needed.</p><p>            // Tell MVC3 to use MEF as its dependency resolver.<br>            var dependencyResolver = new CompositionDependencyResolver(catalog);<br>            DependencyResolver.SetResolver(dependencyResolver);</p><p>            // Tell MVC3 to resolve dependencies in controllers<br>            ControllerBuilder.Current.SetControllerFactory(<br>                new DefaultControllerFactory(<br>                    new CompositionControllerActivator(dependencyResolver)));</p><p>            // Tell MVC3 to resolve dependencies in filters<br>            FilterProviders.Providers.Remove(FilterProviders.Providers.Single(f =&gt; f is FilterAttributeFilterProvider));<br>            FilterProviders.Providers.Add(new CompositionFilterAttributeFilterProvider(dependencyResolver));</p><p>            // Tell MVC3 to resolve dependencies in model validators<br>            ModelValidatorProviders.Providers.Remove(ModelValidatorProviders.Providers.OfType&lt;DataAnnotationsModelValidatorProvider&gt;().Single());<br>            ModelValidatorProviders.Providers.Add(<br>                new CompositionDataAnnotationsModelValidatorProvider(dependencyResolver));</p><p>            // Tell MVC3 to resolve model binders through MEF. Note that a model binder should be decorated<br>            // with [ModelBinderExport].<br>            ModelBinderProviders.BinderProviders.Add(<br>                new CompositionModelBinderProvider(dependencyResolver));<br>        }<br>    }</p><p>No success</p><p>So i try to implement a PartRegistry :</p><p>using System;<br>using System.Collections.Generic;<br>using System.ComponentModel.Composition;<br>using System.IO;<br>using System.Linq;<br>using System.Reflection;<br>using System.Web;<br>using MefContrib.Hosting.Conventions.Configuration;<br>using MefContrib.Hosting.Conventions;<br>using System.Web.Mvc;<br>using MefContrib.Web.Mvc;</p><p>namespace MefLocalTests.Codes<br>{<br>    public class PluginMvcApplicationRegistry : PartRegistry<br>    {<br>        /// &lt;summary&gt;<br>        /// Initializes a new instance of the &lt;see cref="MvcApplicationRegistry"/&gt; class.<br>        /// &lt;/summary&gt;<br>        public PluginMvcApplicationRegistry()<br>        {<br>            Scan(x =&gt;<br>            {<br>                x.Assembly(Assembly.GetExecutingAssembly());<br>                x.Directory(Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "Plugins"));<br>                x.Directory(Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "bin"));<br>            });</p><p>            Part()<br>                .ForTypesAssignableFrom&lt;IController&gt;()<br>                .MakeNonShared()<br>                .AddMetadata(new PartCreationScopeAttribute(PartCreationScope.Default))<br>                .ExportAs&lt;IController&gt;()<br>                .Export()<br>                .Imports(x =&gt;<br>                {<br>                    x.Import().Members(<br>                        m =&gt; new[] { m.GetConstructors().FirstOrDefault(c =&gt; c.GetCustomAttributes(typeof(ImportingConstructorAttribute), false).Length &gt; 0) ?? m.GetGreediestConstructor() });<br>                    x.Import().Members(<br>                        m =&gt; m.GetMembers().Where(mbr =&gt; mbr.GetCustomAttributes(typeof(ImportAttribute), false).Length &gt; 0).ToArray());<br>                });<br>        }<br>    }<br>}</p><p>And</p><p> public static class AppStart_MefContribMVC3<br>    {<br>        public static void Start()<br>        {<br>            // Register the CompositionContainerLifetimeHttpModule HttpModule.<br>            // This makes sure everything is cleaned up correctly after each request.<br>            CompositionContainerLifetimeHttpModule.Register();</p><p>            // Create MEF catalog based on the contents of ~/bin.<br>            //<br>            // Note that any class in the referenced assemblies implementing in "IController"<br>            // is automatically exported to MEF. There is no need for explicit [Export] attributes<br>            // on ASP.NET MVC controllers. When implementing multiple constructors ensure that<br>            // there is one constructor marked with the [ImportingConstructor] attribute.<br>            var catalog = new AggregateCatalog(<br>                new DirectoryCatalog("bin"),<br>                new ConventionCatalog([b]new PluginMvcApplicationRegistry()[/b])); // Note: add your own (convention)catalogs here if needed.</p><p>            // Tell MVC3 to use MEF as its dependency resolver.<br>            var dependencyResolver = new CompositionDependencyResolver(catalog);<br>            DependencyResolver.SetResolver(dependencyResolver);</p><p>            // Tell MVC3 to resolve dependencies in controllers<br>            ControllerBuilder.Current.SetControllerFactory(<br>                new DefaultControllerFactory(<br>                    new CompositionControllerActivator(dependencyResolver)));</p><p>            // Tell MVC3 to resolve dependencies in filters<br>            FilterProviders.Providers.Remove(FilterProviders.Providers.Single(f =&gt; f is FilterAttributeFilterProvider));<br>            FilterProviders.Providers.Add(new CompositionFilterAttributeFilterProvider(dependencyResolver));</p><p>            // Tell MVC3 to resolve dependencies in model validators<br>            ModelValidatorProviders.Providers.Remove(ModelValidatorProviders.Providers.OfType&lt;DataAnnotationsModelValidatorProvider&gt;().Single());<br>            ModelValidatorProviders.Providers.Add(<br>                new CompositionDataAnnotationsModelValidatorProvider(dependencyResolver));</p><p>            // Tell MVC3 to resolve model binders through MEF. Note that a model binder should be decorated<br>            // with [ModelBinderExport].<br>            ModelBinderProviders.BinderProviders.Add(<br>                new CompositionModelBinderProvider(dependencyResolver));<br>        }<br>    }</p><p>No more success</p><p>But if i put the Dll in the bin folder, everything ok</p><p>Could you tell me where is my mistake?</p><p>Thx a lot,</p><p>Dadv</p>'
